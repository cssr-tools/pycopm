# SPDX-FileCopyrightText: 2024 NORCE
# SPDX-License-Identifier: GPL-3.0

"""
Utiliy methods to only create the coarser files by pycopm.
"""

import os
import csv
import numpy as np
from resdata.grid import Grid
from resdata.resfile import ResdataFile
from mako.template import Template
import pandas as pd


def create_deck(dic):
    """Dry run to generate the files"""
    dic["flags"] = "--parsing-strictness=low --enable-dry-run=true"
    os.system(f"{dic['flow']} {dic['deck']}.DATA {dic["flags"]} & wait\n")

    # Read the data
    dic["field"] = "generic"
    dic["props"] = ["poro", "permx", "permy", "permz"]
    dic["grid"] = Grid(f"{dic['exe']}/" + dic["deck"] + ".EGRID")
    dic["ini"] = ResdataFile(f"{dic['exe']}/" + dic["deck"] + ".INIT")
    nc = dic["grid"].nx * dic["grid"].ny * dic["grid"].nz
    dic["con"] = np.array([0 for _ in range(nc)])
    actnum = np.array([0 for _ in range(nc)])
    vol = np.array([0.0 for _ in range(nc)])
    d_z = np.array([0.0 for _ in range(nc)])
    z_z = np.array([0.0 for _ in range(nc)])
    for name in dic["props"]:
        dic[name] = np.array([0.0 for _ in range(nc)])
    n = 0
    for cell in dic["grid"].cells():
        vol[cell.global_index] = cell.volume
        actnum[cell.global_index] = cell.active
        d_z[cell.global_index] = cell.dz
        z_z[cell.global_index] = cell.coordinate[2]
        if cell.active == 1:
            for name in dic["props"]:
                dic[name][cell.global_index] = dic["ini"].iget_kw(name.upper())[0][n]
            n += 1

    # Coarsening
    handle_clusters(dic)
    map_ijk(dic)
    nxyz = dic["nx"] * dic["ny"] * dic["nz"]
    clusters = pd.Series(actnum).groupby(dic["con"]).min()
    # clusters = pd.Series(actnum).groupby(dic["con"]).max()
    # dz_c = pd.Series(d_z).groupby(dic["con"]).min()
    # zmin_c = pd.Series(z_z).groupby(dic["con"]).min()
    # zmax_c = pd.Series(z_z).groupby(dic["con"]).max()
    # rmv = (zmax_c - zmin_c) < dz_c
    # dic["actnum_c"] = [int(clusters[i+1]*rmv[i+1]) for i in range(nxyz)]
    dic["actnum_c"] = [int(clusters[i + 1]) for i in range(nxyz)]
    vol_c = pd.Series(vol * actnum + 1e-10).groupby(dic["con"]).sum()
    for name in dic["props"]:
        c_c = pd.Series(dic[name] * vol * actnum).groupby(dic["con"]).sum()
        dic[f"{name}_c"] = [f"{c_c[i+1]/vol_c[i+1]}" for i in range(nxyz)]
    handle_cp_grid(dic)
    write_grid(dic)
    write_props(dic)
    process_the_deck(dic)
    with open(
        f"{dic['exe']}/{dic['fol']}/{dic["deck"].upper()}_pycopm.DATA",
        "w",
        encoding="utf8",
    ) as file:
        for row in dic["lol"]:
            file.write(row + "\n")


def write_grid(dic):
    """Write the corner-point grid"""
    dic["files"] = [f for f in os.listdir(f"{dic['exe']}") if f.endswith(".INC")]
    for file in dic["files"]:
        copy = True
        for prop in ["PORO", "PERM", "TOPS", "PHI", "FIPNUM", "SATNUM", "NTG"]:
            if prop in file:
                copy = False
        if copy:
            os.system(f"scp -r {dic['exe']}/{file} {dic['exe']}/{dic['fol']}")
    var = {"dic": dic}
    mytemplate = Template(filename=f"{dic['pat']}/template_scripts/common/grid.mako")
    filledtemplate = mytemplate.render(**var)
    with open(f"{dic['exe']}/{dic['fol']}/GRID.INC", "w", encoding="utf8") as f:
        f.write(filledtemplate)


def write_props(dic):
    """Write the coarser properties"""
    for name in dic["props"]:
        dic[f"{name}_c"].insert(0, f"{name.upper()}")
        dic[f"{name}_c"].insert(
            0,
            "-- This file was generated by pycopm https://github.com/cssr-tools/pycopm",
        )
        dic[f"{name}_c"].append("/")
        with open(
            f"{dic['exe']}/{dic['fol']}/{name.upper()}.INC",
            "w",
            encoding="utf8",
        ) as file:
            file.write("\n".join(dic[f"{name}_c"]))


def handle_clusters(dic):
    """Create the coarser clusters"""
    dic["X"] = np.ones(dic["grid"].nx + 1)
    dic["Y"] = np.ones(dic["grid"].ny + 1)
    dic["Z"] = np.ones(dic["grid"].nz + 1)
    dic["X"][range(0, dic["grid"].nx, dic["cijk"][0])] = 0
    dic["Y"][range(0, dic["grid"].ny, dic["cijk"][1])] = 0
    dic["Z"][range(0, dic["grid"].nz, dic["cijk"][2])] = 0
    dic["X"][-1], dic["Y"][-1], dic["Z"][-1] = 0, 0, 0
    n = 0
    m = 1
    for k in range(dic["grid"].nz):
        for j in range(dic["grid"].ny):
            for i in range(dic["grid"].nx):
                if dic["con"][n] == 0:
                    dic["con"][n] = m
                    m += 1
                if (dic["X"][i + 1]) == 1:
                    dic["con"][n + 1] = dic["con"][n]
                if (dic["Y"][j + 1]) == 1:
                    dic["con"][n + dic["grid"].nx] = dic["con"][n]
                if (dic["Z"][k + 1]) == 1:
                    dic["con"][n + dic["grid"].nx * dic["grid"].ny] = dic["con"][n]
                n += 1

    dic["nx"] = dic["grid"].nx - int(sum(dic["X"]))
    dic["ny"] = dic["grid"].ny - int(sum(dic["Y"]))
    dic["nz"] = dic["grid"].nz - int(sum(dic["Z"]))


def map_ijk(dic):
    """Create the mappings to the new i,j,k indices"""
    dic["ic"] = np.array([0 for _ in range(dic["grid"].nx + 1)])
    dic["jc"] = np.array([0 for _ in range(dic["grid"].ny + 1)])
    dic["kc"] = np.array([0 for _ in range(dic["grid"].nz + 1)])
    n = 1
    m = 1
    for i in range(dic["grid"].nx):
        if dic["ic"][n] == 0:
            dic["ic"][n] = m
            m += 1
        if (dic["X"][i + 1]) == 1:
            dic["ic"][n + 1] = dic["ic"][n]
        n += 1
    n = 1
    m = 1
    for j in range(dic["grid"].ny):
        if dic["jc"][n] == 0:
            dic["jc"][n] = m
            m += 1
        if (dic["Y"][j + 1]) == 1:
            dic["jc"][n + 1] = dic["jc"][n]
        n += 1
    n = 1
    m = 1
    for k in range(dic["grid"].nz):
        if dic["kc"][n] == 0:
            dic["kc"][n] = m
            m += 1
        if (dic["Z"][k + 1]) == 1:
            dic["kc"][n + 1] = dic["kc"][n]
        n += 1


def handle_cp_grid(dic):
    """Handle the pillars and zcord for the coarser grid"""
    ir = []
    mr = []
    zc = dic["grid"].export_zcorn()
    cr = dic["grid"].export_coord()
    for i in range(dic["grid"].nx + 1):
        if (dic["X"][i]) == 1:
            for m in range(
                i, (dic["grid"].nx + 1) * (dic["grid"].ny + 1), dic["grid"].nx + 1
            ):
                for l in range(6):
                    mr.append(m * 6 + l)
            for n in range(
                2 * i - 1,
                8 * dic["grid"].nx * dic["grid"].ny * dic["grid"].nz,
                2 * dic["grid"].nx,
            ):
                ir.append(n)
                ir.append(n + 1)

    for j in range(dic["grid"].ny + 1):
        if (dic["Y"][j]) == 1:
            for m in range(j * (dic["grid"].nx + 1), (j + 1) * (dic["grid"].nx + 1)):
                for l in range(6):
                    mr.append(m * 6 + l)
            for n in range(
                (2 * j - 1) * 2 * dic["grid"].nx,
                8 * dic["grid"].nx * dic["grid"].ny * dic["grid"].nz,
                4 * dic["grid"].nx * dic["grid"].ny,
            ):
                for l in range(4 * dic["grid"].nx):
                    ir.append(n + l)

    ir = handle_zcorn(dic, ir)
    dic["zc"] = np.delete(zc, ir, 0)
    dic["cr"] = np.delete(cr, mr, 0)


def handle_zcorn(dic, ir):
    """Process the zcorn"""
    for k in range(dic["grid"].nz + 1):
        if (dic["Z"][k]) == 1:
            for n in range(
                (2 * k - 1) * 4 * dic["grid"].nx * dic["grid"].ny,
                (2 * k + 1) * 4 * dic["grid"].nx * dic["grid"].ny,
            ):
                ir.append(n)
    return ir


def process_the_deck(dic):
    """Identify and modified the required keywords"""
    dic["lol"] = []
    dic["dimens"] = False
    dic["removeg"] = False
    dic["welspecs"] = False
    dic["compdat"] = False
    with open(dic["deck"] + ".DATA", "r", encoding="utf8") as file:
        for row in csv.reader(file):
            nrwo = str(row)[2:-2]
            if 0 < nrwo.find("\\t"):
                nrwo = nrwo.replace("\\t", " ")
            if "DIMENS" in nrwo:
                dic["dimens"] = True
                continue
            if dic["dimens"]:
                if "/" in nrwo:
                    dic["dimens"] = False
                continue
            if "GRID" in nrwo:
                dic["removeg"] = True
                dic["lol"].append(nrwo)
                dic["lol"].append("INCLUDE")
                dic["lol"].append("'GRID.INC' /")
                continue
            if dic["removeg"]:
                if "PROPS" in nrwo:
                    dic["removeg"] = False
                else:
                    continue
            if handle_wells(dic, nrwo):
                continue
            dic["lol"].append(nrwo)


def handle_wells(dic, nrwo):
    """Add the necessary keywords and right i,j,k coarser well indices"""
    if "WELSPECS" in nrwo:
        dic["welspecs"] = True
        dic["lol"].append(nrwo)
        return True
    if dic["welspecs"]:
        edit = nrwo.split()
        if len(edit) > 2:
            edit[2] = str(dic["ic"][int(edit[2])])
            edit[3] = str(dic["jc"][int(edit[3])])
            dic["lol"].append(" ".join(edit))
            return True
        dic["welspecs"] = False
    if "COMPDAT" in nrwo:
        dic["compdat"] = True
        dic["lol"].append(nrwo)
        return True
    if dic["compdat"]:
        edit = nrwo.split()
        if len(edit) > 2:
            edit[1] = str(dic["ic"][int(edit[1])])
            edit[2] = str(dic["jc"][int(edit[2])])
            edit[3] = str(dic["kc"][int(edit[3])])
            edit[4] = str(dic["kc"][int(edit[4])])
            dic["lol"].append(" ".join(edit))
            return True
        dic["compdat"] = False
    return False
